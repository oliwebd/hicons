#!/usr/bin/env node
import { promises as fs } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import chokidar from "chokidar";
import { glob } from "glob";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ===== CONFIG =====
const WATCH_GLOB = "layouts/**/*.html";
const DEBOUNCE_MS = 800;
const ICONS_FOLDER = join(__dirname, "../icons/minified"); // <- updated path

// ===== CORE FUNCTION =====
async function generateIcons() {
  // Determine partial path
  let PARTIAL_PATH = join("layouts", "_partials", "icons.html");
  if (await exists(join("layouts", "partials", "icons.html"))) {
    PARTIAL_PATH = join("layouts", "partials", "icons.html");
  }

  // Read existing partial
  let existingContent = "";
  let existingIcons = new Set();
  if (await exists(PARTIAL_PATH)) {
    existingContent = await fs.readFile(PARTIAL_PATH, "utf-8");
    const matches = existingContent.matchAll(/{{ else if eq \$icon "([\w-]+)"/g);
    for (const m of matches) existingIcons.add(m[1]);
  }

  // Scan Hugo layouts for icon usage
  const files = glob.sync(WATCH_GLOB);
  const iconNames = new Set();
  for (const file of files) {
    const content = await fs.readFile(file, "utf-8");
    const matches = content.matchAll(/{{\s*partial\s+"icons\.html"\s+\(dict\s+"name"\s+"([\w-]+)"/g);
    for (const m of matches) iconNames.add(m[1]);
  }

  // Filter new icons
  const newIcons = [...iconNames].filter(name => !existingIcons.has(name));
  if (newIcons.length === 0) {
    console.log("‚úÖ No new icons to add. Partial is up to date.");
    return;
  }

  // Generate new icons content from local minified SVGs
  let newContent = "";
  for (const name of newIcons) {
    const svgPath = join(ICONS_FOLDER, `${name}.svg`);
    if (!(await exists(svgPath))) {
      console.warn(`‚ö† Icon not found in minified folder: ${name}`);
      continue;
    }
    let svg = await fs.readFile(svgPath, "utf-8");

    // Inject classes + aria-hidden
    svg = svg.replace(
      /<svg([^>]*)>/,
      '<svg$1 class="{{ $classes }}" aria-hidden="true">'
    );

    newContent += `{{ else if eq $icon "${name}" }}
${svg}
`;
  }

  // Combine with existing content
  let finalContent = existingContent
    ? existingContent.replace(/\{\{ end \}\}\s*$/, newContent + "\n{{ end }}")
    : `{{/* Auto-generated by hicons */}}\n{{ $icon := .name }}\n{{ $classes := .class | default "" }}\n{{ if false }}\n${newContent}\n{{ end }}`;

  // Ensure directory exists
  await fs.mkdir(dirname(PARTIAL_PATH), { recursive: true });

  // Write updated file
  await fs.writeFile(PARTIAL_PATH, finalContent, "utf-8");
  console.log(`‚ú® Updated icons partial at: ${PARTIAL_PATH}`);
}

// ===== WATCH MODE =====
function watchMode() {
  console.log("üëÄ hicons watching for layout changes...");
  let timer;

  const watcher = chokidar.watch(WATCH_GLOB, { ignoreInitial: false });
  const trigger = async (event, path) => {
    clearTimeout(timer);
    timer = setTimeout(async () => {
      console.log(`üîÅ [${event}] ${path}`);
      try {
        await generateIcons();
      } catch (err) {
        console.error("‚ùå Error:", err.message);
      }
    }, DEBOUNCE_MS);
  };

  watcher.on("add", trigger);
  watcher.on("change", trigger);
  watcher.on("unlink", trigger);
}

// ===== UTILS =====
async function exists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

// ===== CLI ENTRY =====
const args = process.argv.slice(2);
if (args.includes("--watch")) {
  watchMode();
} else {
  await generateIcons();
}


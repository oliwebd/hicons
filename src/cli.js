#!/usr/bin/env node
import { promises as fs } from "fs";
import { join, dirname, resolve } from "path";
import { fileURLToPath } from "url";
import chokidar from "chokidar";
import glob from "glob";
import { icons } from "lucide";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ===== CONFIG =====
const WATCH_GLOB = "layouts/**/*.html";
const DEBOUNCE_MS = 800; // delay rebuild if multiple files change quickly

// ===== CORE FUNCTION =====
async function generateIcons() {
  // Determine partial path
  let PARTIAL_PATH = "";
  if (await exists(join("layouts", "partials", "icons.html"))) {
    PARTIAL_PATH = join("layouts", "partials", "icons.html");
  } else if (await exists(join("layouts", "_partials", "icons.html"))) {
    PARTIAL_PATH = join("layouts", "_partials", "icons.html");
  } else {
    PARTIAL_PATH = join("layouts", "_partials", "icons.html");
  }

  // Read existing partial
  let existingContent = "";
  let existingIcons = new Set();

  if (await exists(PARTIAL_PATH)) {
    existingContent = await fs.readFile(PARTIAL_PATH, "utf-8");
    const matches = existingContent.matchAll(/{{ else if eq \$icon "([\w-]+)"/g);
    for (const m of matches) existingIcons.add(m[1]);
  }

  // Scan Hugo layouts
  const files = glob.sync(WATCH_GLOB);
  const iconNames = new Set();

  for (const file of files) {
    const content = await fs.readFile(file, "utf-8");
    const matches = content.matchAll(/{{\s*partial\s+"icons\.html"\s+\(dict\s+"name"\s+"([\w-]+)"/g);
    for (const m of matches) iconNames.add(m[1]);
  }

  // Filter new icons
  const newIcons = [...iconNames].filter(name => !existingIcons.has(name));

  if (newIcons.length === 0) {
    console.log("‚úÖ No new icons to add. Partial is up to date.");
    return;
  }

  // Generate new icons content
  let newContent = "";
  for (const name of newIcons) {
    const icon = icons[name];
    if (!icon) {
      console.warn(`‚ö† Icon not found in Lucide: ${name}`);
      continue;
    }
    const svg = icon.toSvg({ width: 24, height: 24, stroke: "currentColor" });
    newContent += `
{{ else if eq $icon "${name}" }}
${svg.replace(/<svg/, '<svg class="{{ $classes }}" aria-hidden="true"')}
`;
  }

  // Combine with existing content
  let finalContent = existingContent
    ? existingContent.replace(/\{\{ end \}\}\s*$/, newContent + "\n{{ end }}")
    : `{{/* Auto-generated by hicons */}}\n{{ $icon := .name }}\n{{ $classes := .class | default "" }}\n{{ if false }}\n${newContent}\n{{ end }}`;

  // Ensure directory exists
  await fs.mkdir(dirname(PARTIAL_PATH), { recursive: true });

  // Write updated file
  await fs.writeFile(PARTIAL_PATH, finalContent, "utf-8");
  console.log(`‚ú® Updated icons partial at: ${PARTIAL_PATH}`);
}

// ===== WATCH MODE =====
function watchMode() {
  console.log("üëÄ hicons watching for layout changes...");
  let timer;

  const watcher = chokidar.watch(WATCH_GLOB, { ignoreInitial: false });

  const trigger = async (event, path) => {
    clearTimeout(timer);
    timer = setTimeout(async () => {
      console.log(`üîÅ [${event}] ${path}`);
      try {
        await generateIcons();
      } catch (err) {
        console.error("‚ùå Error:", err.message);
      }
    }, DEBOUNCE_MS);
  };

  watcher.on("add", trigger);
  watcher.on("change", trigger);
  watcher.on("unlink", trigger);
}

// ===== UTILS =====
async function exists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

// ===== CLI ENTRY =====
const args = process.argv.slice(2);
if (args.includes("--watch")) {
  watchMode();
} else {
  await generateIcons();
}

